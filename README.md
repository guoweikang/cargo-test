# Cargo-Kbuild: Kconfig Integration for Cargo Package Management

A minimal viable prototype (MVP) demonstrating the integration of Linux Kconfig configuration system with Rust's Cargo package management ecosystem.

## üéØ Core Innovation

Cargo-Kbuild enables **parallel configuration access** pattern where all crates (including dependencies) read from a single global `.config` file, rather than tree-based feature propagation typical in Cargo projects.

### Key Differences from Traditional Cargo Features

| Aspect | Traditional Cargo | Cargo-Kbuild |
|--------|------------------|--------------|
| **Configuration Source** | Features defined per package | Global `.config` file |
| **Feature Propagation** | Tree-based (parent ‚Üí child) | Parallel (all crates ‚Üí global config) |
| **Dependency Control** | `dep/feature` syntax | Dependencies read config directly |
| **Use Case** | Application variants | System-wide configuration |

## üì¶ Project Structure

```
cargo-test/
‚îú‚îÄ‚îÄ .config                      # Global configuration (from Kconfig)
‚îú‚îÄ‚îÄ Kconfig                      # Configuration definitions
‚îú‚îÄ‚îÄ cargo-kbuild/                # Wrapper tool
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src/main.rs
‚îú‚îÄ‚îÄ crates/
‚îÇ   ‚îú‚îÄ‚îÄ kernel_irq/              # Type A: Basic kbuild crate
‚îÇ   ‚îú‚îÄ‚îÄ kernel_task/             # Type A: With dependencies
‚îÇ   ‚îú‚îÄ‚îÄ kernel_schedule/         # Type A: Multiple dependencies
‚îÇ   ‚îú‚îÄ‚îÄ kernel_net/              # Type B: Internal + external deps
‚îÇ   ‚îú‚îÄ‚îÄ network_utils/           # Type B: Internal library
‚îÇ   ‚îî‚îÄ‚îÄ legacy_driver/           # Type C: Traditional Cargo features
‚îú‚îÄ‚îÄ Cargo.toml                   # Workspace configuration
‚îî‚îÄ‚îÄ src/main.rs                  # Demo application
```

## üöÄ Quick Start

### 1. Build the cargo-kbuild Tool

```bash
cargo build -p cargo-kbuild
```

### 2. Run with Default Configuration

```bash
./target/debug/cargo-kbuild build
```

### 3. Run the Demo Application

```bash
./target/debug/cargo-kbuild run
```

Expected output:

```
üöÄ ============================================
üöÄ  Cargo-Kbuild MVP Demo
üöÄ ============================================

üì¶ Initializing subsystems...

üîß [SCHEDULE] Initialize scheduler
üîß [IRQ] Initialize interrupt handling
üîß [IRQ] Initialize SMP interrupt handling
üîß [IRQ] Preemptive interrupt handling enabled
üîß [TASK] Initialize task management
üîß [TASK] Multi-core task scheduling enabled
...
```

### 4. Use Custom Configuration

```bash
# Create a custom config file
cat > debug.config << EOF
CONFIG_SMP=n
CONFIG_PREEMPT=n
CONFIG_NET=y
CONFIG_ASYNC=y
CONFIG_DEBUG=y
CONFIG_LOG_LEVEL=5
EOF

# Build with custom config
./target/debug/cargo-kbuild build --kconfig debug.config

# Run with custom config
./target/debug/cargo-kbuild run --kconfig debug.config
```

## üîß How It Works

### Configuration Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   .config       ‚îÇ  ‚Üê Generated by Kconfig (external tool)
‚îÇ CONFIG_SMP=y    ‚îÇ
‚îÇ CONFIG_NET=y    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚Üì              ‚Üì              ‚Üì              ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  App   ‚îÇ     ‚îÇkernel_ ‚îÇ    ‚îÇkernel_  ‚îÇ   ‚îÇ  tokio   ‚îÇ
    ‚îÇ        ‚îÇ     ‚îÇ  irq   ‚îÇ    ‚îÇ  net    ‚îÇ   ‚îÇ          ‚îÇ
    ‚îÇ reads  ‚îÇ     ‚îÇ reads  ‚îÇ    ‚îÇ reads   ‚îÇ   ‚îÇ  reads   ‚îÇ
    ‚îÇCONFIG_ ‚îÇ     ‚îÇCONFIG_ ‚îÇ    ‚îÇCONFIG_  ‚îÇ   ‚îÇ CONFIG_  ‚îÇ
    ‚îÇ  SMP   ‚îÇ     ‚îÇ  SMP   ‚îÇ    ‚îÇ  NET    ‚îÇ   ‚îÇ  ASYNC   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

All crates **directly read** the same global configuration, enabling true parallel configuration access.

### Cargo-Kbuild Tool Workflow

1. **Parse `.config` file** ‚Üí Extract enabled CONFIG_* options
2. **Scan workspace** ‚Üí Find kbuild-enabled crates (via metadata or naming)
3. **Validate features** ‚Üí Detect forbidden sub-feature specifications
4. **Generate flags**:
   - `RUSTFLAGS="--cfg CONFIG_SMP --cfg CONFIG_NET ..."`
   - `--features "CONFIG_SMP,CONFIG_NET,..."`
5. **Invoke cargo** ‚Üí Pass generated flags to native cargo command

### Crate Identification Methods

#### Method 1: Metadata (Recommended)

```toml
[package.metadata.kbuild]
enabled = true
```

#### Method 2: Naming Convention

Features with `CONFIG_` prefix are automatically recognized as kbuild-related.

## üìù Feature Dependency Rules

### ‚úÖ Allowed Pattern

```toml
[features]
CONFIG_NET = ["tokio", "async-std"]  # ‚úÖ Declare dependencies only
```

### ‚ùå Forbidden Pattern

```toml
[features]
CONFIG_NET = ["tokio/rt-multi-thread"]  # ‚ùå Specifying sub-features
```

### Why This Rule?

In the kbuild paradigm, dependencies control their own features by reading the global `.config`:

```rust
// In tokio crate (if it were kbuild-enabled)
#[cfg(CONFIG_ASYNC)]
pub fn enable_multi_thread_runtime() { ... }
```

This maintains **separation of concerns**: each crate decides what CONFIG_* options mean for its own implementation.

## üîç Conflict Detection

Cargo-kbuild **automatically detects** and **rejects** forbidden patterns:

```bash
$ ./target/debug/cargo-kbuild build

‚ùå Validation error in crate 'my_crate': Feature 'CONFIG_NET' specifies sub-feature: 'tokio/rt-multi-thread'
When using kbuild, dependencies should not specify sub-features.
Expected: 'tokio'
Reason: Dependency features are controlled by global config.
```

## üìö Example Crates

### Type A: Basic Kbuild Crate (`kernel_irq`)

```toml
[package.metadata.kbuild]
enabled = true

[features]
CONFIG_SMP = []
CONFIG_PREEMPT = []
```

```rust
#[cfg(CONFIG_SMP)]
pub fn handle_smp_interrupt() { ... }

#[cfg(not(CONFIG_SMP))]
pub fn handle_single_core_interrupt() { ... }
```

### Type B: Mixed Dependencies (`kernel_net`)

```toml
[package.metadata.kbuild]
enabled = true

[dependencies]
network_utils = { path = "../network_utils", optional = true }
log = { version = "0.4", optional = true }

[features]
CONFIG_NET = ["network_utils"]  # ‚úÖ Only declare dependency
CONFIG_DEBUG = ["log"]           # ‚úÖ Not specifying log/features
```

### Type C: Traditional Cargo (`legacy_driver`)

```toml
# No kbuild metadata - uses traditional Cargo features
[features]
usb = []
pci = []
```

## üéì Technical Details

### RUSTFLAGS vs Features

- **`--cfg` flags** (via RUSTFLAGS): Control conditional compilation within code
  - Applied globally to all crates during compilation
  - Used for: `CONFIG_SMP`, `CONFIG_PREEMPT`, `CONFIG_ASYNC`, etc.

- **`--features` flags**: Control optional dependencies and code sections
  - Enable optional dependencies (e.g., `CONFIG_NET` ‚Üí include `kernel_net`)
  - Applied at the package level

### Compilation Warnings

You may see warnings like:

```
warning: unexpected `cfg` condition name: `CONFIG_SMP`
   |
19 | #[cfg(CONFIG_SMP)]
   |       ^^^^^^^^^^
```

These are **expected** and **harmless**. They occur because Rust's check-cfg lint doesn't recognize custom cfg names set via RUSTFLAGS. The code compiles and works correctly.

To silence these warnings, add to each crate's `Cargo.toml`:

```toml
[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = [
    'cfg(CONFIG_SMP)',
    'cfg(CONFIG_PREEMPT)',
    'cfg(CONFIG_NET)',
    # ... other CONFIG_* options
] }
```

## üî¨ Comparison with Linux Rust

| Aspect | Linux Rust | Cargo-Kbuild |
|--------|-----------|--------------|
| **Scope** | Linux kernel modules | General Cargo projects |
| **Build System** | Kbuild (Make-based) | Cargo (native) |
| **Config Tool** | Kconfig (C-based) | External Kconfig tool |
| **Integration** | Deep kernel integration | Wrapper over cargo |
| **Dependencies** | Kernel-internal only | Full Cargo ecosystem |

**Cargo-Kbuild** brings Kconfig's powerful configuration system to the broader Cargo ecosystem while maintaining compatibility with existing Cargo tooling.

## üß™ Testing & Validation

### Test Conflict Detection

Create a test crate with forbidden pattern:

```bash
# Add to a crate's Cargo.toml
[features]
CONFIG_TEST = ["tokio/rt-multi-thread"]

# Try to build
./target/debug/cargo-kbuild build

# Expected: Error message about sub-feature specification
```

### Test Different Configurations

```bash
# Test minimal config
echo "CONFIG_SMP=y" > minimal.config
./target/debug/cargo-kbuild run --kconfig minimal.config

# Test full config
echo "CONFIG_SMP=y
CONFIG_PREEMPT=y
CONFIG_NET=y
CONFIG_ASYNC=y
CONFIG_DEBUG=y" > full.config
./target/debug/cargo-kbuild run --kconfig full.config
```

### Verify Feature-Based Behavior

The demo application output changes based on enabled features:

- `CONFIG_SMP=y`: "Initialize SMP interrupt handling"
- `CONFIG_SMP=n`: "Initialize single-core interrupt handling"
- `CONFIG_NET=y`: Network subsystem initializes and tests
- `CONFIG_NET=n`: "Network subsystem disabled"

## üèóÔ∏è Architecture Principles

### 1. Parallel Configuration Access

Unlike traditional Cargo where features flow down the dependency tree, Cargo-Kbuild enables all crates to read the same global configuration simultaneously.

### 2. Dependency Autonomy

Each crate (including dependencies) decides independently what configuration options mean for its implementation. Parent crates don't dictate child behavior.

### 3. Separation of Concerns

- **Configuration Definition**: Kconfig files
- **Configuration Selection**: External Kconfig tools (menuconfig, etc.)
- **Configuration Application**: cargo-kbuild wrapper
- **Build Execution**: Native cargo

### 4. Cargo Compatibility

Cargo-kbuild is a wrapper that generates appropriate flags for native cargo. Projects remain compatible with standard Cargo tooling when not using kbuild features.

## üìñ Use Cases

- **System Software**: OS components, drivers, embedded systems
- **Configurable Applications**: Multiple deployment profiles
- **Modular Projects**: Feature-rich applications with complex dependencies
- **Multi-Target Builds**: Different configurations for different platforms

## ü§ù Contributing

This is an MVP demonstration. Potential enhancements:

- [ ] Integration with actual Kconfig tools (menuconfig, xconfig)
- [ ] Build script generation for automatic cfg checks
- [ ] Cargo plugin/extension mechanism
- [ ] Configuration validation and dependencies checking
- [ ] IDE integration for configuration visualization

## üìÑ License

[Specify your license here]

## üôè Acknowledgments

- Linux Kconfig system for configuration management inspiration
- Rust Cargo team for the excellent package management system
- Linux Rust project for pioneering Rust in system software

---

**Note**: This MVP demonstrates core concepts. Production use would require additional tooling, error handling, and integration with actual Kconfig build tools.
