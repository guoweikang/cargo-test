# Cargo-Kbuild

Linux Kconfig-style configuration system for Rust/Cargo projects.

## Features

- Global configuration via `.config` files (like Linux kernel)
- Conditional compilation with `#[cfg(CONFIG_*)]`
- Integer/string constants generation
- Dependency validation
- Zero compilation warnings

## Quick Start

1. **Install**:
   ```bash
   cargo install --path cargo-kbuild
   ```

2. **Create `.config`** (via Kconfig tools or manually):
   ```
   SMP=y
   NET=y
   LOG_LEVEL=3
   MAX_CPUS=8
   DEFAULT_SCHEDULER="cfs"
   ```

3. **Use like cargo**:
   ```bash
   cargo kbuild build
   cargo kbuild test
   cargo kbuild run
   cargo kbuild check
   ```

All your configuration settings are automatically applied!

## Architecture

**How it works**:
- `.config` file is EXTERNAL - generated by Kconfig tools (e.g., `make menuconfig`) or created manually
- cargo-kbuild READS `.config`, generates constants, sets compiler flags, and calls cargo
- Cargo.toml features are ONLY for optional dependencies, not for declaring config usage
- Any kbuild-enabled crate can use ANY `CONFIG_*` globally in source code

**What cargo-kbuild does**:
1. Read existing `.config` file
2. Generate `target/kbuild/config.rs` with constants
3. Generate `.cargo/config.toml` for zero warnings
4. Set RUSTFLAGS for conditional compilation
5. Validate dependencies
6. Call cargo build

## Usage

```bash
cargo kbuild build                           # Build with .config
cargo kbuild test                            # Run tests with .config
cargo kbuild run                             # Run binary with .config
cargo kbuild check                           # Check code with .config
cargo kbuild clippy                          # Run clippy with .config
cargo kbuild build --kconfig custom.config  # Use custom config
cargo kbuild test --lib -- --nocapture      # Pass args through
cargo kbuild --help                          # Show help
cargo kbuild --version                       # Show version
```

## Configuration in Code

### Boolean Configs
```rust
#[cfg(SMP)]
fn init_smp() {
    println!("SMP enabled");
}
```

### Integer/String Configs
```rust
use kbuild_config::*;

fn init() {
    println!("Log level: {}", LOG_LEVEL);
    println!("Max CPUs: {}", MAX_CPUS);
    println!("Scheduler: {}", DEFAULT_SCHEDULER);
}
```

## Feature Declaration

**Only declare features for optional dependencies**:

```toml
# ✅ CORRECT: Has optional dependency
[dependencies]
kernel_net = { path = "crates/kernel_net", optional = true }

[features]
NET = ["kernel_net"]

# ❌ WRONG: No optional dependency
[features]
SMP = []  # Don't declare - just use in code
```

## Enable Kbuild

Add to your crate's `Cargo.toml`:

```toml
[package.metadata.kbuild]
enabled = true
```

Then use any `CONFIG_*` in your code without declaring it.

## Documentation

- [User Guide](cargo-kbuild/README.md) - Detailed usage instructions
- [Implementation Details](IMPLEMENTATION_DETAILS.md) - Technical architecture

## Example

See `crates/` directory for examples:
- `kernel_irq/` - No features (no optional deps)
- `kernel_task/` - No features (no optional deps)  
- `kernel_schedule/` - No features (no optional deps)
- `kernel_net/` - Used as optional dependency
- `demo_mixed_deps/` - Using config constants

## Comparison with Cargo Features

| Aspect | Cargo Features | cargo-kbuild |
|--------|----------------|--------------|
| Config Method | `--features` | `.config` file |
| Propagation | Tree-based | Global shared |
| Config Source | Command line | Config file |
| Feature Purpose | Features + optional deps | Optional deps only |
| Declaration | Required in Cargo.toml | Use directly in code |
| Use Case | Applications | Kernel/firmware |

## License

MIT OR Apache-2.0
